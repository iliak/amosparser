<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="eng"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- base href="http://alvyn.sourceforge.net/amos_file_formats.html" --><style type="text/css">body { margin-left:0;margin-right:0;margin-top:0; }#google-cache-hdr {background:#f5f5f5 !important;font:13px arial,sans-serif !important;text-align:left !important;color:#202020 !important;border:0 !important;margin:0 !important;border-bottom:1px solid #cecece !important;line-height:16px !important ;padding:16px 28px 24px 28px !important;}#google-cache-hdr * {display:inline !important;font:inherit !important;text-align:inherit !important;color:inherit !important;line-height:inherit !important;background:none !important;border:0 !important;margin:0 !important;padding:0 !important;letter-spacing:0 !important;}#google-cache-hdr a {text-decoration:none !important;color:#1a0dab !important;}#google-cache-hdr a:hover { text-decoration:underline !important; }#google-cache-hdr a:visited { color:#609 !important; }#google-cache-hdr div { display:block !important;margin-top:4px !important; }#google-cache-hdr b {font-weight:bold !important;display:inline-block !important;direction:ltr !important;}</style></head><body><div id="google-cache-hdr" dir="ltr"><div>Ceci est le cache Google de <a href="http://alvyn.sourceforge.net/amos_file_formats.html" dir="ltr">http://alvyn.sourceforge.net/amos_file_formats.html</a>. Il s'agit d'un instantané de la page telle qu'elle était affichée le 10 juil. 2016 08:47:28 GMT. </div><div>La <a href="http://alvyn.sourceforge.net/amos_file_formats.html" dir="ltr">page actuelle</a> peut avoir changé depuis cette date. <a href="http://support.google.com/websearch/bin/answer.py?hl=fr&amp;p=cached&amp;answer=1687222">En savoir plus</a></div><div></div><div><span style="display:inline-block !important;margin-top:8px !important;margin-right:104px !important;white-space:nowrap !important;"><span style="margin-right:28px !important;"><span style="font-weight:bold !important;">Version intégrale</span></span><span style="margin-right:28px !important;"><a href="http://webcache.googleusercontent.com/search?q=cache:rNUyMjwiDbsJ:alvyn.sourceforge.net/amos_file_formats.html&amp;num=1&amp;client=ubuntu&amp;hl=fr&amp;gl=fr&amp;strip=1&amp;vwsrc=0">Version en texte seul</a></span><span style="margin-right:28px !important;"><a href="http://webcache.googleusercontent.com/search?q=cache:rNUyMjwiDbsJ:alvyn.sourceforge.net/amos_file_formats.html&amp;num=1&amp;client=ubuntu&amp;hl=fr&amp;gl=fr&amp;strip=0&amp;vwsrc=1">Afficher la source</a></span></span><span style="display:inline-block !important;margin-top:8px !important;color:#717171 !important;">Astuce&nbsp;: Pour trouver rapidement votre terme de recherche sur cette page, appuyez sur <b>Ctrl+F</b> ou sur <b>⌘+F</b> (Mac), puis utilisez la barre de recherche.</span></div></div><div style="position:relative;">
<!--?xml version="1.0" encoding="iso-8859-1"?-->



<meta name="author" content="Stuart Caie">
<title>AMOS file formats</title>



<h1>AMOS file formats</h1>

<h2><a name="contents">Table of contents</a></h2>
<ul>
  <li><a href="#about">About the formats</a></li>
  <li><a href="#source_code">AMOS source code file format</a>
  <ul>
    <li><a href="#tokenised_code">Tokenised BASIC code format</a>
    <ul>
      <li><a href="#special_print">Specially printed tokens</a></li>
      <li><a href="#special_size">Specially sized tokens</a></li>
      <li><a href="#decryption">Procedure decryption source code</a></li>
    </ul>
    </li>
  </ul>
  </li><li><a href="#sprite_bank">AMOS Sprite and Icon formats</a></li>
  <li><a href="#banks">AMOS Memory Bank formats</a>
  <ul>
    <li><a href="#music_bank">AMOS Music Bank format</a></li>
    <li><a href="#amal_bank">AMOS AMAL Bank format</a></li>
    <li><a href="#menu_bank">AMOS Menu Bank format</a></li>
    <li><a href="#data_bank">AMOS Data Bank format</a></li>
    <li><a href="#work_bank">AMOS Work Bank format</a></li>
    <li><a href="#asm_bank">AMOS Asm Bank format</a></li>
    <li><a href="#pacpic_bank">AMOS Picture Bank format</a></li>
    <li><a href="#samples_bank">AMOS Samples Bank format</a></li>
  </ul>
  </li>
</ul>

<h2><a name="about">About the formats</a></h2>

<p>
AMOS is the name given to a number of BASIC-like programming languages
created for the Amiga by François Lionet, who is also known for the
BASIC-like language STOS for the Atari ST and ClickPlay for the IBM
PC. AMOS languages include "AMOS The Creator", "Easy AMOS" and "AMOS
Professional".
</p>

<p>
This document attempts to cover all file formats defined by the AMOS
software itself. File formats invented in third party software shall not
be included. This is a first draft and many formats are not included.
</p>

<p>
All multi-byte integers are big-endian unless otherwise specified.
</p>

<h2><a name="source_code">AMOS source code file format</a></h2>
<p>
AMOS source code is normally stored in a file with the extension ".AMOS".
It begins with 16 bytes of ASCII text from the following list:
</p>

<table border="1">
<tbody><tr><th>Text</th><th>Tested?</th><th>Saved from which AMOS?</th></tr>

<tr><td>"AMOS Pro101V\0\0\0\0"</td><td>Yes</td><td>AMOS
Professional</td></tr>

<tr><td>"AMOS Basic V134 "</td><td>Yes</td><td>AMOS Pro, but AMOS 1.3
compatible</td></tr>

<tr><td>"AMOS Basic V1.3 "</td><td>Yes</td><td>AMOS The Creator
v1.3</td></tr>

<tr><td>"AMOS Basic V1.00"</td><td>Yes</td><td>AMOS The Creator v1.0 -
v1.2</td></tr>

<tr><td>"AMOS Pro101v\0\0\0\0"</td><td>No</td><td>AMOS
Professional</td></tr>

<tr><td>"AMOS Basic v134 "</td><td>No</td><td>AMOS Pro, but AMOS 1.3
compatible</td></tr>

<tr><td>"AMOS Basic v1.3 "</td><td>No</td><td>AMOS The Creator
v1.3</td></tr>

<tr><td>"AMOS Basic v1.00"</td><td>No</td><td>AMOS The Creator v1.0 -
v1.2</td></tr>

</tbody></table>

<p>
As you can see the upper-case "V" shows that the source code has been
tested, and the lower-case "v" shows that the source code has not been
tested. This refers to whether the AMOS interpreter has performed a sanity
test on all lines of code, and found no syntax errors.
</p>

<p>
After the  16 byte header is a  4-byte 32-bit unsigned integer stating the
number of bytes of tokenised BASIC code. This is immediately followed by the BASIC code itself, for the length given.
</p>

<p>
Finally, the 4-bytes ASCII identifier "AmBs" is given, followed by a
2-byte 16-bit unsigned integer with the number of memory banks to
follow. This is followed by the banks themselves, individually sized. Each
bank can either be a sprite bank, an icon bank or a regular memory
bank. There is no more data in the source code file after this. If a
sprite bank is given, it always occupies bank 1 and there must not be
another sprite bank or regular memory bank with a bank number of 1. If an
icon bank is given, it always occupies bank 2 and there must not be
another icon bank or regular memory bank with a bank number of 2.
</p>

<h3><a name="tokenised_code">Tokenised BASIC code format</a></h3>

<p>
The tokenised BASIC code is a stream of tokenised lines. Each tokenised line has the following format:
</p>

<ul>
<li>1 byte: The length of this line in words (2 bytes), including this
byte. To get the length of the line in bytes, double this value.</li>

<li>1 byte: The indent level of this line. AMOS automatically indents
lines to show program structure. If printing this line as ASCII text, you
should print {indent level + 1} space characters as the beginning of the
line, or no spaces if the value is less than 2.</li>

<li>many bytes: a sequence of tokens. Each token is at least two bytes,
and all tokens are rounded to to a multiple of two bytes. Each token is
individually sized. The tokens always end with a compulsory null
token.</li>
</ul>

<p>
AMOS considers each token as a signed 16-bit number. Token values between
0x0000 and 0x004E are special printing and have differing sizes, all
others are simply a signed offset into AMOS's internal token table. The
text of the token in the internal token table is what should be
printed. Some of these tokens have special size rules, all others are 2
bytes in size.
</p>

<h4><a name="special_print">Specially printed tokens</a></h4>

<table border="1">
<tbody><tr><th>Token</th><th>Type</th><th>Interpretation</th></tr>

<tr><td>0x0000</td><td>null token</td><td>Marks the end of line. Always 2
bytes long.</td></tr>
<tr><td>0x0006</td><td>Variable reference<br>e.g. Print <b>XYZ</b></td>
<td rowspan="4">
<ul>
<li>2 bytes: token (0x0006, 0x000C, 0x0012 or 0x0018)</li>
<li>2 bytes: unknown purpose </li>
<li>1 byte: length of the ASCII string for the variable or label name</li>
<li>1 byte: flags, for tokens 0x0006, 0x0012 and 0x0018:
<ul>
<li>bit 1 set: this is a floating point reference, e.g. "XYZ#"</li>
<li>bit 2 set: this is a string reference, e.g. "XYZ$"</li>
</ul>
</li>
<li>many bytes: the ASCII string, with the above-given length.</li>
</ul>
The ASCII string is null terminated and its length is rounded up to a
multiple of two.
</td>
</tr>
<tr><td>0x000C</td><td>Label<br>e.g. <b>XYZ</b>: or <b>190</b> at the
start of a line</td></tr>

<tr><td>0x0012</td><td>Procedure call reference<br>e.g. <b>XYZ</b>["hello"]</td></tr>

<tr><td>0x0018</td><td>Label reference<br>e.g. Goto <b>XYZ</b></td></tr>

<tr><td>0x0026</td><td>String with double quotes<br>e.g. "hello"</td>
<td rowspan="2">
<ul>
<li>2 bytes: token (0x0026 or 0x002E)</li>
<li>2 bytes: the length of the string</li>
<li>many bytes: the ASCII string, with the above given length</li>
</ul>
The ASCII string is null terminated and its length is rounded up to a
multiple of two.
</td>
</tr>

<tr><td>0x002E</td><td>String with single quotes<br>e.g. 'hello'</td></tr>

<tr><td>0x001E</td><td>Binary integer value<br>e.g. %100101</td>
<td rowspan="3">
<ul>
<li>2 bytes: token (0x001E, 0x0036 or 0x003E)</li>
<li>4 bytes: the integer value</li>
</ul>
</td>
</tr>

<tr><td>0x0036</td><td>Hexidecimal integer value<br>e.g. $80FAA010</td></tr>

<tr><td>0x003E</td><td>Decimal integer value<br>e.g. 1234567890</td></tr>

<tr><td>0x0046</td><td>Floating point value<br>e.g. 3.14</td>
<td>
<ul>
<li>2 bytes: token (0x0046)</li>
<li>4 bytes: the single-precision floating point value.
<ul>
<li>bits 31-8: mantissa (24 bits)</li>
<li>bit 7: sign bit. Positive if 0, negative if 1</li>
<li>bits 6-0: exponent</li>
</ul>
</li>
</ul>
An exponent of 0 means 0.0, regardless of mantissa. Counting from MSB (23)
to LSB (0), each bit set in the mantissa is 2^(mantissa_bit + exponent -
88)
</td>
</tr>

<tr><td>0x004E</td><td>Extension command</td>
<td>
<ul>
<li>2 bytes: token (0x004E)</li>
<li>1 byte: extension number (1 to 26)</li>
<li>1 byte: unused</li>
<li>2 bytes: signed 16-bit offset into extension's token table</li>
</ul>
</td>
</tr>
</tbody></table>

<h4><a name="special_size">Specially sized tokens</a></h4>

<table border="1">
<tbody><tr><th>Token</th><th>Type</th><th>Interpretation</th></tr>

<tr><td>0x064A</td><td>Rem</td><td rowspan="2">
Print the remark string in addition to the remark token.
<ul>
<li>2 bytes: token (0x064A or 0x0652)</li>
<li>1 byte: unused</li>
<li>1 byte: length of remark string</li>
<li>many bytes: the ASCII remark string, with the above-given length.</li>
</ul>
The ASCII string is null terminated and its length is rounded up to a
multiple of two.
</td></tr>
<tr><td>0x0652</td><td>Rem type 2</td></tr>

<tr><td>0x023C</td><td>For</td><td rowspan="7">
<ul>

<li>2 bytes: token (0x023C, 0x0250, 0x0268, 0x027E, 0x02BE, 0x02D0 or
0x0404)</li>
<li>2 bytes: unknown purpose</li>
</ul>
</td></tr>
<tr><td>0x0250</td><td>Repeat</td></tr>
<tr><td>0x0268</td><td>While</td></tr>
<tr><td>0x027E</td><td>Do</td></tr>
<tr><td>0x02BE</td><td>If</td></tr>
<tr><td>0x02D0</td><td>Else</td></tr>
<tr><td>0x0404</td><td>Data</td></tr>

<tr><td>0x0290</td><td>Exit If</td><td rowspan="3">
<ul>
<li>2 bytes: token (0x0290, 0x029E or 0x0376)</li>
<li>4 bytes: unknown purpose</li>
</ul>
</td></tr>
<tr><td>0x029E</td><td>Exit</td></tr>
<tr><td>0x0316</td><td>On</td></tr>

<tr><td>0x0376</td><td>Procedure</td><td>
<ul>
<li>2 bytes: token (0x0376)</li>
<li>4 bytes: number of bytes to corresponding End Proc line
<br>(start of line + 8 + above = start of End Proc line)
<br>(start of line + 8 + 6 + above = line after End Proc line)
</li>
<li>2 bytes: part of seed for encryption</li>
<li>1 byte: flags
<ul>
<li>bit 7: if set, procedure is folded</li>
<li>bit 6: if set, procedure is locked and shouldn't be unfolded</li>
<li>bit 5: if set, procedure is currently encrypted</li>
<li>bit 4: if set, procedure contains compiled code and not tokens</li>

<li>1 byte: part of seed for encryption</li>
</ul>
</li></ul></td></tr>
</tbody></table>

<h4><a name="decryption">Procedure decryption source code</a></h4>
<p>
If you should find a procedure (0x0376) token with the "is encrypted" bit
set, run this C function on the code and it will decrypt the contents of
the procedure.
</p>

<pre>/* fetches a 4-byte integer in big-endian format */
#define EndGetM32(a)  ((((a)[0])&lt;&lt;24)|(((a)[1])&lt;&lt;16)|(((a)[2])&lt;&lt;8)|((a)[3]))
/* fetches a 2-byte integer in big-endian format */
#define EndGetM16(a)  ((((a)[0])&lt;&lt;8)|((a)[1]))

void decrypt_procedure(unsigned char *src) {
  unsigned char *line, *next, *endline;
  unsigned int key, key2, key3, size;

  /* ensure src is a pointer to a line with the PROCEDURE token on it */
  if (EndGetM16(&amp;src[2]) != 0x0376) return;

  /* do not operate on compiled procedures */
  if (src[10] &amp; 0x10) return;

  /* size+8+6 is the start of the line after ENDPROC */
  size = EndGetM32(&amp;src[4]);
  endline = &amp;src[size+8+6];
  line = next = &amp;src[src[0] * 2];

  /* initialise encryption keys */
  key = (size &lt;&lt; 8) | src[11];
  key2 = 1;
  key3 = EndGetM16(&amp;src[8]);

  while (line &lt; endline) {
    line = next;
    next = &amp;line[line[0] * 2];

    /* decrypt one line */
    for (line += 4; line &lt; next;) {
      *line++ ^= (key &gt;&gt; 8) &amp; 0xFF;
      *line++ ^=  key       &amp; 0xFF;
      key  += key2;
      key2 += key3;
      key = (key &gt;&gt; 1) | (key &lt;&lt; 31);
    }
  }
  src[10] ^= 0x20; /* toggle "is encrypted" bit */
}
</pre>

<h2><a name="sprite_bank">AMOS Sprite and Icon bank formats</a></h2>
<p>
A sprite bank and an icon bank share very similar attributes. They define
graphic data which can be drawn onscreen.
</p>

<ul>
<li>4 bytes: "AmSp" for sprites (bank 1) or "AmIc" for icons (bank 2)</li>
<li>2 bytes: the number of sprites or icons to follow</li>
<li>many bytes: the above-counted sprites or icons</li>
<li>64 bytes: a 32-entry colour palette. Each entry has the Amiga COLORx
hardware register format, which is 0x0RGB, where R, G and B represent red,
green and blue colour components and are between 0x0 (minimum) and 0xF
(maximum).</li>
</ul>

<p>
Each sprite or icon has this format:
</p>

<ul>
<li>2 bytes: width, in 16-bit words</li>
<li>2 bytes: height, in raster lines</li>
<li>2 bytes: depth, in bitplanes (1 to 5)</li>
<li>2 bytes: hot-spot X co-ordinate</li>
<li>2 bytes: hot-spot Y co-ordinate</li>
<li>many bytes: width*height*depth*2 bytes of planar graphic data</li>
</ul>

<h2><a name="banks">AMOS Memory Bank formats</a></h2>

<p>
An AMOS Memory bank is simply a named block of data. AMOS allows for 15
such banks in an AMOS program, and they can also be loaded and saved at
runtime using the "Load" and "Save" commands. Each bank has a standard 20
byte header, although the "length" field in this header does not count the
"name" field of this header as part of the header. Each bank can be
located in "chip" memory, which is accessible to the Amiga's custom
graphics and sound processors, or it can be located in "fast" memory,
which is only accessible to the CPU. The header format is as follows:
</p>

<ul>
<li>4 bytes: the ASCII identifier "AmBk"</li>
<li>2 bytes: the bank number (1-15)</li>
<li>2 bytes: 0 for chip memory bank, 1 for fast memory bank</li>
<li>4 bytes: bank length, but only bits 27 to 0. Bits 28 and 29 are undefined,
not part of the length field. Bit 30 means "try chip memory", bit 31 means
"try fast memory" if set.
</li><li>8 bytes: the bank name. It is always an unterminated ASCII string
which is padded with spaces.
</li></ul>

<p>
The header is followed by the bank data, which is {bank length - 8} bytes
long.
</p>

<h3><a name="music">AMOS Music Bank format</a></h3>

<p>
This bank has the name "Music" and is created with various conversion
utilities shipped with AMOS. It is played back with the Music extension.
See the accompanying <a href="http://alvyn.sourceforge.net/amos_music_format.html">AMOS Music file
format</a> document for more details.
</p>

<h3><a name="amal">AMOS AMAL Bank format</a></h3>

<p>
This bank has the name "Amal". It contains instructions in AMOS Animation
Language format. This will be described in more detail in a later draft of
this document.
</p>

<h3><a name="menu">AMOS Menu Bank format</a></h3>

<p>
This bank has the name "Menu". It contains pull-down menu definitions.
This will be described in more detail in a later draft of this document.
</p>

<h3><a name="datas">AMOS Data Bank format</a></h3>

<p>
This bank has the name "Datas". It is created in AMOS using the "Reserve
As Data" command, and has no specific format.
</p>

<h3><a name="work">AMOS Work Bank format</a></h3>

<p>
This bank has the name "Work". It is created in AMOS using the "Reserve
As Work" command, and has no specific format. As a Work bank, it is not
saved as part of the source code, unlike normal data banks.
</p>

<h3><a name="asm">AMOS Asm Bank format</a></h3>

<p>
This bank has the name "Asm". It contains Amiga machine code that was
loaded into a bank using the "Pload" command and has no specific format
(other than containing MC680x0 binary code).
</p>

<h3><a name="pacpic">AMOS Picture Bank format</a></h3>

<p>
This bank has the name "Pac.Pic." and is created with the Compact
extension's "Pack" command. See the accompanying <a href="http://alvyn.sourceforge.net/amos_pacpic_format.html">AMOS Pac.Pic. file format</a> document for
more details.
</p>

<h3><a name="samples">AMOS Samples Bank format</a></h3>

<p>
This bank has the name "Samples" and is created with the Sample Bank
Editor shipped with AMOS. The samples can be played back with the Music
extension. The format of the bank is as follows:
</p>

<ul>
<li>20 byte: the regular bank header, as described above</li>
<li>2 bytes: the number of samples in this bank</li>
<li>many bytes: A list of offsets, each 4 bytes long, to each sample.  The
offset is relative to the location of the "number of samples" field
above.</li>
</ul>

<p>
The format of each sample is as follows:
</p>

<ul>
<li>8 bytes: the name for the sample, in ASCII.</li>
<li>2 bytes: the frequency of the sample in hertz.</li>
<li>4 bytes: the length of the sample in bytes.</li>
<li>many bytes: the sample data itself, a stream of twos complement signed
8-bit PCM samples</li>
</ul>


</div></body></html>